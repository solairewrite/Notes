# 预测
## 创建`FPredictionKey`
1. 客户端执行GA时,会创建辅助结构体`FScopedPredictionWindow`,在它的(客户端版本)构造函数中,为`int16 FPredictionKey::Current`赋了新值  
随后调用`CallServerTryActivateAbility`通过RPC将PredictionKey传给服务器  

2. 服务器收到客户端传来的PredictionKey时,也会创建辅助结构体`FScopedPredictionWindow`,在它的(服务器版本)构造函数中,复制客户端传来的值  

## 服务器给客户端反馈GA是否激活成功
1. 激活失败时,调用`ClientActivateAbilityFailed`,客户端会广播`FPredictionKeyDelegates::FDelegates::RejectedDelegates`,这个代理关联了当前的PredictionKey  

2. 无论激活成功或者失败,在`FScopedPredictionWindow`析构时,都会将当前的PredictionKey同步给客户端,客户端会调用`FReplicatedPredictionKeyItem::OnRep`  
函数中会广播`FPredictionKeyDelegates::FDelegates::CaughtUpDelegates`,这个代理同样关联了当前的PredictionKey  

`FReplicatedPredictionKeyMap UAbilitySystemComponent::ReplicatedPredictionKeyMap;`,注释上说他是最后一个同步的属性,以确保OnRep的顺序  

## 客户端创建预测的GE
创建新的`FActiveGameplayEffect`时会传入PredictionKey,将GE与PredictionKey关联  
然后绑定RejectedDelegates/CaughtUpDelegates,即无论是服务器拒绝,或客户端捕捉到服务器的同步时,都会调用`RemoveActiveGameplayEffect_NoReturn`  

```
FActiveGameplayEffect* FActiveGameplayEffectsContainer::ApplyGameplayEffectSpec(const FGameplayEffectSpec& Spec, FPredictionKey& InPredictionKey, bool& bFoundExistingStackableGE)
{
    AppliedActiveGE = new(GameplayEffects_Internal) FActiveGameplayEffect(NewHandle, Spec, GetWorldTime(), GetServerWorldTime(), InPredictionKey);

    InPredictionKey.NewRejectOrCaughtUpDelegate(FPredictionKeyEvent::CreateUObject(Owner, &UAbilitySystemComponent::RemoveActiveGameplayEffect_NoReturn, AppliedActiveGE->Handle, -1));
}
```

## 收到服务器返回时,客户端如何处理预测的GE
### 如果激活失败
客户端广播RejectedDelegates,删除预测的GE  

### 如果激活成功
1. 先同步GE  
GAS中激活的GE存储在 `FActiveGameplayEffectsContainer UAbilitySystemComponent::ActiveGameplayEffects;`,会从服务器同步给客户端  
`FActiveGameplayEffectsContainer`里面保存激活的GE数组 `TArray<FActiveGameplayEffect>`  
当服务器验证成功时,GE同步到客户端,客户端会调用 `FActiveGameplayEffect::PostReplicatedAdd`  
此时客户端会为同步过来的GE再次执行功能,而客户端自己本身有一个预测的GE,短时间内会有2个相同的GE  

```
void FActiveGameplayEffect::PostReplicatedAdd(const struct FActiveGameplayEffectsContainer &InArray)
{
   	bool ShouldInvokeGameplayCueEvents = true;
	if (PredictionKey.IsLocalClientKey())
	{
		// 如果客户端已经预测过了,那么就不再重复调用GC
		if (InArray.HasPredictedEffectWithPredictedKey(PredictionKey))
		{
			ShouldInvokeGameplayCueEvents = false;
		}
	}

    // 添加GE(修改Attribute,tag等)
    const_cast<FActiveGameplayEffectsContainer&>(InArray).InternalOnActiveGameplayEffectAdded(*this);
}
```

2. 再同步PredictionKey  
客户端广播CaughtUpDelegates,删除预测的GE  

## 预测蒙太奇
客户端播放蒙太奇时,将蒙太奇与PredictionKey绑定,服务器激活失败时,客户端广播RejectedDelegates取消播放  

```
float UAbilitySystemComponent::PlayMontage(UGameplayAbility* InAnimatingAbility, FGameplayAbilityActivationInfo ActivationInfo, UAnimMontage* NewAnimMontage, float InPlayRate, FName StartSectionName, float StartTimeSeconds)
{
	PredictionKey.NewRejectedDelegate().BindUObject(this, &UAbilitySystemComponent::OnPredictiveMontageRejected, NewAnimMontage);
}

void UAbilitySystemComponent::OnPredictiveMontageRejected(UAnimMontage* PredictiveMontage)
{
	AnimInstance->Montage_Stop(MONTAGE_PREDICTION_REJECT_FADETIME, PredictiveMontage);
}
```