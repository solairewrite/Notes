# UE4渲染模块 01 方法论,遮挡剔除,几何渲染
原文链接 https://zhuanlan.zhihu.com/p/57561144  

## 渲染方法论
游戏中讨论的都是实时渲染(RealTime Rendering, RTR)  
即随着游戏内相机的移动,要尽可能无延迟的展示视口内容  

图形优化可以归纳成6点方法论:  

1. 流水线: 并发多线程,使硬件的利用率达到最高  

2. 预计算: 能事先计算的就尽量事先做,降低Runtime的运行成本  
如静态光的lightmap  

3. 局部化: 只在可见的局部区域里做事情  
如屏幕空间反射的计算SSR  

4. 先粗后精: 先用消耗低的方法缩小计算范围,再用消耗大的方法执行精确计算  
如八叉树遮挡查询  

5. 时空互换: 用时间换空间或空间换时间  
如lightmap就是空间换时间  

6. 负担转移: 使用`stat unit`查看如果是CPU的瓶颈,又不可以进一步优化了,可以考虑将CPU的计算移至GPU计算  
如骨骼动画计算可以移至GPU做  

## 渲染之前: 遮挡查询
遮挡查询: 只渲染镜头可见的场景,剔除看不见的场景  
这部分发生在GPU渲染之前,实在CPU做的逐Object的遮挡查询  

UE4使用4种遮挡处理方法,按性能消耗由低到高排列如下:  

1. 距离剔除: 离镜头太远的物件直接隐去,不去绘制  

2. 视锥剔除: 镜头能看到的区域是一个锥体,锥体以外的部分可以不去绘制  
具体是用八叉树先粗后细筛选进入视锥体的对象  

3. 预计算可见性剔除: 是用于室内场景,如门外可以看到哪些区域,这些可以预计算,不用实时计算  

4. 遮挡剔除: 最费性能,需要逐对象查询  

UE4会有限是用消耗低的方法排除掉大部分不用渲染的对象,再用遮挡剔除这种最精细的方法进一步计算  

## 几何渲染
几何渲染可以分成3部分:  

### 1.GPU端像素级别的遮挡查询  
在渲染primitive顶点之前,需要拿到深度信息,这样就知道那个顶点应该被渲染,那个不需要渲染了  

### 2.解析CPU端传来的draw primitive绘制指令(`draw call`)  
GPU是逐个drawcall渲染的,drawcall是CPU向GPU发出的一次渲染指令,让GPU绘制指定的几何体  
渲染器会把相同材质的对象放到相邻drawcall中处理,这样可以节省让硬件切换渲染状态的耗时  

UE4查看drawcall数量的命令是`stat RHI`  
一般移动端在1000个左右,PC端在2000-3000  

drawcall涉及到CPU向GPU数据的传递,这个传递的代价远大于三角形本身的绘制  

降低drawcall的通用处理方案是进行模型的合并,将空间邻近,相同材质,相同渲染状态的小模型,合并成一个大模型  
这样就只需要提交一次drawcall既可以完成绘制了  

模型合并后,虽然drawcall的数量降低,但要考虑他的副作用:  

1. 遮挡剔除力度减弱,哪怕视锥体内出现合并模型的一个面片,也会去渲染整个合并模型  

2. lightmap占用更多空间  

3. 碰撞计算变难  

4. 模型占用内存更大,相同的小模型在内存中只要一份,合并后,多个相同模型顶点信息都被完整保留  

相对于drawcall,控制面数影响小些,可以降低后续光照计算与pixel shader的复杂度  
减面的常用方法是`LOD(Level of Detail)`,按镜头与物体的距离来替换不同精度的模型  
比如离得近用1000面的模型,离得远用100面的模型  

### 3.顶点计算 vertex shader  
CPU传来的顶点是三维的,需要降维投影,这个算法过程被称为vertex shader  
vertex shader将三维顶点的数据输出成屏幕空间的二维顶点  
这其中要经理模型空间到世界空间,世界空间到视口空间,视口空间到屏幕空间的矩阵变换  
