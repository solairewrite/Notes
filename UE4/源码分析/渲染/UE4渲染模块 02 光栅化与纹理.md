# UE4渲染模块 02 光栅化与纹理
## 光栅化
将二维的顶点组合成三角形之后,要考虑如何绘制到屏幕上,显示器由一格格像素构成的  
需要计算哪些像素被三角形覆盖了,再对这些被覆盖的像素进行着色  
对顶点/三角形像素化的过程称之为光栅化  

同一块像素区域,因为不同drawcall,被多次绘制,这种现象被称为 overshading / quad overdraw  
三角形面数影响 overshading,因为三角形越密,重合的像素就会越多,就越可能发生quad重复渲染  
这也是为什么使用LOD的原因  

## GBuffer
GBuffer是延迟渲染才有的东西,实际是渲染出了多张不同信息的2D图片,然后用类似ps的方法来处理这些图片  

+ GBufferA  

缓存了WorldNormal,即模型在世界坐标下的法向量,用以记录朝向  

+ GBufferB  

缓存了物理渲染的PBR参数,其中:  

R分量: 黑白mask标识哪部分是金属(全金属没有漫反射)  
G分量: 黑白mask标识高光  
B分量: 黑白mask标识粗糙度(反应发射光是否有比较一致的方向性)  

+ GBufferC  

缓存了不带光照的图,即ViewMode里面的unlit,可以认为呈现的是物体的固有色  

剩下的GBufferD,GBufferE,GBufferF都用作特殊的buffer,比如深度缓冲,标识半透明物体的缓冲等  

最后合成的图像本质就是这些buffer缓存的2D图像经过某种图像算法合成出来的  
当场景简单时,这些消耗会超过传统的前向渲染  
但如果场景复杂时,特别是多光源的情况下,采用GBuffer的延迟渲染就会远低于前向渲染  
再复杂的场景也会简化为2D的图像处理  

## Textures
对像素着色时,需要采样对应的纹理,因为内存限制,需要对导入的纹理进行各种压缩  

对于游戏中使用的纹理,都会自动对其 mipmap 化,称为多级渐进纹理,是自动按照比例缩小原图  
引擎会自动选择合适的 mipmap 精度进行绘制  
为了匹配视点远近,需要使用不同精度的贴图  
远处的物体占用的像素很少,如果仍用高精度贴图,那么采样UV覆盖的范围就会很少,取出来后看上去就像是噪点  

因为每级mipmap的长宽都是上一级长宽的一半,所以要求长宽必须是2的幂次方,这样才可以让引擎正常生成多级的mipmap  
