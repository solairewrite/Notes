# C++ 面试题 02
>1. 虚函数的原理,虚函数表存放的位置  

虚函数的多态性: 当父类指针指向子类对象的地址时,父类指针根据赋值给他的不同子类指针,动态的调用子类的函数  

原理: 编译器为每个类对象添加一个隐藏成员,隐藏成员中保存了一个指向函数地址数组的指针,称为虚指针  
这种数组称为虚函数表,即每个类使用一个虚函数表,每个类对象用一个虚表指针  
如果派生类重写了基类的虚方法,该派生类的虚函数表将保存重写的虚函数地址  

调用虚函数时,程序将查看储存在对象中的虚函数表地址,转向相应的虚函数表,使用类中声明的第几个虚函数  
程序就使用数组的第几个函数地址,并执行该函数  

友元函数不能为虚,因为友元函数不是类成员  

虚表存放的位置: 全局数据区  

>2. override和overload  

override: 重写  
overload: 重载,函数的参数类型,个数,顺序至少一个不同  

>3. union了解吗,为什么要内存对其,内存对其怎么实现  

在一个union变量内,允许装入union定义的任何一种数据,这些数据共享一段内存,以达到节省空间的目的  
占用的内存长度为最长的成员的内存长度  

为什么要内存对其: 
平台原因: 不是所有平台都能访问任意地址上的任意数据,有些平台只能在某些地址处读取某些特定类型的数据  
硬件原因: 内存对其后,CPU的内存访问速度提升  
CPU读取内存是一块一块读取的,如果未对其,需要访问多次然后拼接  

内存对其怎么实现:
struct的成员,第一个数据放在偏移为0的地方,以后每个成员的偏移为自身大小的整数倍  
所有的数据成员对其完成后,结构体大小变为最大成员的整数倍  

struct StructOne { 
                 长度        对齐      偏移     区间
    char   a;       1       1         0      [0]     
    double b;       8       8         8      [8,  15]
    int    c;       4       4         16     [16, 19]
    short  d;       2       2         20     [20, 21]
} // 最后补齐成为8的倍数,即24

>4. C++强枚举类型  

enum class  
优点:  
1. 强作用域,强枚举成员的名称不会被输出到其父作用域空间  
2. 转换限制,不可以与整形隐式的相互转换  
3. 可以指定底层类型,默认为int

>5. volatile关键字  

1. volatile类型的变量,在读取时总会返回最新写入的值  
直接从内存中读取,跳过寄存器缓存  

2. 访问时不会执行加锁操作  

可以用在多线程中,共享的标志  

